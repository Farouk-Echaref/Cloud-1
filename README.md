# Cloud-1

![alt text](ansible_playbooks-scaled.jpg)

```bash
# bootstrap the infrastructre
ansible-playbook -i inventory.ini playbook.yml
```

Each play in a playbook defines a set of hosts and executes tasks to achieve a specific goal. Within a play, tasks are organized into roles or defined directly, with each task invoking an Ansible module to perform an action.

- resource for future optimization:
https://www.redhat.com/en/blog/faster-ansible-modules

---

## **Ansible Inventory Approach**

Ansible's **inventory** is a list of hosts (servers or machines) that you manage. It defines the systems where your tasks will run, and it can group hosts logically for better management. Ansible supports both **static** (defined in a file) and **dynamic** (generated by a script) inventory.

### **Key Concepts of Inventory:**
- **Static Inventory**: A simple list of hosts defined in an `.ini` or `.yaml` file.
- **Dynamic Inventory**: Generated at runtime, typically used for cloud environments where hosts may change frequently.
- **Groups**: Hosts can be grouped together, allowing you to apply tasks to specific subsets of systems.

---

### **Example of Static Inventory (INI format)**

An **INI-style** inventory file (`inventory.ini`) defines hosts and groups:
```ini
[web_servers]
web1.example.com
web2.example.com

[db_servers]
db1.example.com
db2.example.com

[all_servers:children]
web_servers
db_servers
```

- **`[web_servers]`**: Defines a group of web servers.
- **`[db_servers]`**: Defines a group of database servers.
- **`[all_servers:children]`**: Combines the previous two groups (web and db) into a parent group.

This inventory file is used in your playbooks to specify which group or host you want to target for specific tasks.

#### **Using the Inventory in a Playbook**
```yaml
- name: Install Nginx on web servers
  hosts: web_servers
  tasks:
    - name: Install Nginx
      apt:
        name: nginx
        state: present
```

In this example, Ansible will target **only the `web_servers` group** (i.e., `web1.example.com` and `web2.example.com`) and install Nginx.

---

### **Example of Static Inventory (YAML format)**

An **YAML-style** inventory file (`inventory.yml`) is another option for organizing hosts:
```yaml
all:
  children:
    web_servers:
      hosts:
        web1.example.com:
        web2.example.com:
    db_servers:
      hosts:
        db1.example.com:
        db2.example.com:
```

This format achieves the same result as the INI-style file, but it's in YAML format, which some users prefer for its readability.

---

### **Dynamic Inventory**

In cases where your infrastructure is dynamic (such as in cloud environments like AWS, Azure, or GCP), you can use **dynamic inventory** scripts to generate the list of hosts.

For example, with AWS, you can use the **`ec2.py` script** to query AWS and retrieve the list of EC2 instances.

```bash
ansible -i ec2.py all -m ping
```

This command will use the **`ec2.py`** dynamic inventory script to query your AWS environment and then run the `ping` module on all discovered instances.

---

### **Benefits of Using Inventory:**
- **Flexibility**: Define static groups or use dynamic inventory for constantly changing environments.
- **Scalability**: Easily manage large infrastructures by grouping hosts logically (e.g., by role, environment, etc.).
- **Efficiency**: You can run tasks only on specific hosts or groups rather than on all managed systems.

- resource: https://docs.ansible.com/ansible/latest/inventory_guide/intro_inventory.html

---

## **Ansible Modular Approach**

Ansible's **modular approach** revolves around using reusable, self-contained components called **modules** to perform automation tasks. These modules handle specific functions like installing packages, managing files, configuring services, or deploying applications.  

### Key Aspects:
- **Idempotency**: Ensures tasks only change the system when necessary.
- **Declarative Syntax**: Users define the desired state, and Ansible enforces it.
- **Reusability**: Modules can be used across multiple playbooks and roles.
- **Extensibility**: Custom modules can be written in Python, Bash, or other languages.
- **Role-based Organization**: Roles structure tasks, handlers, templates, and variables into reusable units.

Ansible provides **built-in modules** (e.g., `yum`, `apt`, `copy`, `service`, `shell`) and supports **custom modules** for specialized tasks, making automation flexible and scalable.

### **Example: Using a Built-in Ansible Module (`copy`)**
The `copy` module is used to transfer files from the control node to managed hosts.

#### **Playbook Using the `copy` Module**
```yaml
- name: Copy a file to remote host
  hosts: all
  tasks:
    - name: Copy a file to /tmp directory
      copy:
        src: myfile.txt
        dest: /tmp/myfile.txt
        owner: root
        group: root
        mode: '0644'
```
👉 This ensures `myfile.txt` is copied to `/tmp` on all target hosts with the correct permissions.

---

### **Example: Custom Ansible Module (Python)**
A simple custom module (`hello.py`) that prints a message.

#### **Step 1: Create the Custom Module (`library/hello.py`)**
```python
#!/usr/bin/python

from ansible.module_utils.basic import AnsibleModule

def main():
    module = AnsibleModule(
        argument_spec={
            "name": {"type": "str", "required": False, "default": "World"},
        }
    )

    name = module.params["name"]
    message = f"Hello, {name}!"

    module.exit_json(changed=False, message=message)

if __name__ == "__main__":
    main()
```

#### **Step 2: Use the Custom Module in a Playbook**
```yaml
- name: Test Custom Module
  hosts: localhost
  tasks:
    - name: Run custom hello module
      hello:
        name: "Ansible User"
      register: result

    - debug:
        msg: "{{ result.message }}"
```

👉 This will output:
```
TASK [debug] 
ok: [localhost] => {
    "msg": "Hello, Ansible User!"
}
```

### **Key Points**
- **Built-in modules** (like `copy`) simplify common automation tasks.
- **Custom modules** allow adding functionality that isn't available in built-in modules.
- Custom modules are stored in the `library/` directory and used like built-in ones.

- resource: https://www.redhat.com/en/topics/automation/what-is-an-ansible-module
- resource for ansible playbooks: https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_intro.html
- resource for docker module: https://docs.ansible.com/ansible/latest/collections/community/docker/docker_image_module.html#ansible-collections-community-docker-docker-image-module
- resource for docker module: https://www.redhat.com/en/blog/container-images-ansible
- resource for working with loops: https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_loops.html
- resource for working with copy module and syntax: https://docs.ansible.com/ansible/latest/collections/ansible/builtin/copy_module.html
- resource for working with the copy module: https://www.youtube.com/watch?v=_kh3rjhG3Bw
- resource using dictionaries in ansible: https://www.middlewareinventory.com/blog/ansible-dict/
- resource looping over list of dicts: https://stackoverflow.com/questions/55425311/ansible-iterate-over-a-list-of-dictionaries-loop-vs-with-items
- resource list and dicts : https://www.redhat.com/en/blog/ansible-lists-dictionaries-yaml

---

## **Ansible Roles Approach**

Ansible's **roles** provide a structured way to organize and reuse automation tasks. Roles group related tasks, variables, templates, files, and handlers into independent units, making playbooks cleaner, more maintainable, and reusable.

### **Key Concepts of Roles:**
- **Directory Structure**: Roles are organized into a predefined directory structure for easy management.
- **Reusability**: A role can be reused across different playbooks and projects.
- **Modularity**: Roles encapsulate related components, making the playbook more readable and maintainable.

#### **Role Directory Structure**  
A typical role directory looks like this:
```
my_role/
├── defaults/
│   └── main.yml        # Default variables
├── files/
│   └── myfile.txt      # Files to be copied to target hosts
├── handlers/
│   └── main.yml        # Handlers (e.g., restart service)
├── meta/
│   └── main.yml        # Metadata (e.g., dependencies)
├── tasks/
│   └── main.yml        # Main tasks (the core functionality of the role)
├── templates/
│   └── mytemplate.j2   # Jinja2 templates
└── vars/
    └── main.yml        # Variables specific to this role
```

---

### **Example: Using Roles**

#### **Step 1: Define a Simple Role**

In the `tasks/main.yml` of a role, you define the tasks:
```yaml
# my_role/tasks/main.yml
- name: Install Nginx
  apt:
    name: nginx
    state: present

- name: Start Nginx service
  service:
    name: nginx
    state: started
    enabled: yes
```

#### **Step 2: Use the Role in a Playbook**
```yaml
- name: Setup Web Server
  hosts: web_servers
  roles:
    - my_role
```

#### **Step 3: Role with Default Variables**

In `defaults/main.yml`:
```yaml
# my_role/defaults/main.yml
nginx_port: 80
```

You can use this variable in the role’s tasks:
```yaml
# my_role/tasks/main.yml
- name: Configure Nginx to listen on custom port
  template:
    src: nginx.conf.j2
    dest: /etc/nginx/nginx.conf
  notify: Restart Nginx
```

#### **Step 4: Handlers for Restarting Nginx**

In `handlers/main.yml`:
```yaml
# my_role/handlers/main.yml
- name: Restart Nginx
  service:
    name: nginx
    state: restarted
```

---

### **Benefits of Using Roles**
- **Separation of Concerns**: Roles group related tasks and components, making them easier to manage and understand.
- **Modular**: Roles can be reused in multiple playbooks.
- **Scalable**: Easily scale automation by adding new tasks or modifying existing ones within roles without changing the overall structure of the playbook.


- resource: https://spacelift.io/blog/ansible-roles
- resource: https://docs.ansible.com/ansible/2.9/user_guide/playbooks_reuse_roles.html?highlight=roles
- resource: https://docs.ansible.com/ansible/2.9/user_guide/playbooks_reuse_roles.html?highlight=roles
- resource: https://www.techcrumble.net/2019/12/how-install-docker-and-docker-compose-using-ansible-playbooks/

---

## **Managing Directories in Ansible**

Ansible provides the `file` module to manage directories, including creating, deleting, and modifying their permissions. Directories can be created on remote hosts with specific ownership and permissions.

---

### **Example: Creating a Directory Using the `file` Module**
The `file` module is commonly used for directory management.

#### **Playbook to Create a Directory**
```yaml
- name: Create a directory on remote hosts
  hosts: all
  tasks:
    - name: Ensure /opt/mydir exists
      file:
        path: /opt/mydir
        state: directory
        owner: myuser
        group: mygroup
        mode: '0755'
```

#### **Explanation:**
- **`path`**: The directory location (`/opt/mydir`).
- **`state: directory`**: Ensures that the specified path is a directory.
- **`owner`** & **`group`**: Sets ownership to `myuser:mygroup`.
- **`mode`**: Defines permissions (`0755` means read/write/execute for the owner and read/execute for others).

---

### **Example: Creating Multiple Directories**
You can create multiple directories using a loop.

```yaml
- name: Create multiple directories
  hosts: all
  tasks:
    - name: Ensure directories exist
      file:
        path: "{{ item }}"
        state: directory
        mode: '0755'
      loop:
        - /opt/project1
        - /opt/project2
        - /var/logs/app
```

🔹 This ensures that `/opt/project1`, `/opt/project2`, and `/var/logs/app` exist with the specified permissions.

---

### **Example: Creating Parent Directories**
If you need to create a directory along with its parent directories, use `file` as shown:

```yaml
- name: Create a nested directory structure
  hosts: all
  tasks:
    - name: Ensure /var/www/html/app exists (including parents)
      file:
        path: /var/www/html/app
        state: directory
        mode: '0755'
```
💡 **The `file` module automatically creates missing parent directories**, so there's no need for extra steps.

---

### **Example: Removing a Directory**
If you want to **remove** a directory, set `state: absent`.

```yaml
- name: Remove a directory
  hosts: all
  tasks:
    - name: Delete /tmp/old_data directory
      file:
        path: /tmp/old_data
        state: absent
```
🔹 This will **delete** the directory `/tmp/old_data` **if it exists**.

---

### **Example: Using Ansible Roles for Directory Management**
You can create a **role** to manage directories systematically.

#### **Directory Structure for the Role (`manage_dirs/`)**
```
manage_dirs/
├── tasks/
│   └── main.yml
├── vars/
│   └── main.yml
```

#### **Define Directories in `vars/main.yml`**
```yaml
directories:
  - /opt/app1
  - /opt/app2
  - /var/logs/app
```

#### **Define Tasks in `tasks/main.yml`**
```yaml
- name: Ensure necessary directories exist
  file:
    path: "{{ item }}"
    state: directory
    mode: '0755'
  loop: "{{ directories }}"
```

#### **Use the Role in a Playbook**
```yaml
- name: Setup directories
  hosts: all
  roles:
    - manage_dirs
```
👉 This role ensures all directories defined in `vars/main.yml` are created.

---

### **Important Points Summary**
- **Create a directory**: Use `file` with `state: directory`.
- **Set ownership & permissions**: Use `owner`, `group`, and `mode`.
- **Create multiple directories**: Use a `loop`.
- **Remove a directory**: Set `state: absent`.
- **Use roles**: To manage directories more efficiently.

- resource for managing files using Ansible: https://stackoverflow.com/questions/22844905/how-to-create-a-directory-using-ansible
- resource for managing files using Ansible: https://spacelift.io/blog/ansible-create-directory

---

## **Managing Docker Compose in Ansible with `community.docker.docker_compose_v2`**  

The **`community.docker.docker_compose_v2`** module allows you to manage Docker Compose projects with Ansible. It can **start, stop, remove, pull, or restart** containers using a `docker-compose.yml` file.

---

### **1️Installing the Required Collection**
Before using the module, ensure the `community.docker` collection is installed:  

```bash
ansible-galaxy collection install community.docker
```

Also, ensure **Docker** and **Docker Compose V2** are installed on the target machine.

---

### **Basic Example: Running a Docker Compose Service**
#### **Playbook to Deploy a Docker Compose Stack**
```yaml
- name: Deploy Docker Compose services
  hosts: all
  tasks:
    - name: Start services using Docker Compose
      community.docker.docker_compose_v2:
        project_src: /opt/docker_app
        state: present
```

#### **Explanation:**
- **`project_src: /opt/docker_app`** → The directory where `docker-compose.yml` is located.
- **`state: present`** → Ensures the services are up and running.

---

### **Example: Defining a `docker-compose.yml` File**
Your `docker-compose.yml` should be in the **`project_src`** directory (`/opt/docker_app` in this case):

```yaml
version: '3.8'
services:
  web:
    image: nginx
    ports:
      - "80:80"
  db:
    image: mariadb
    environment:
      MYSQL_ROOT_PASSWORD: rootpass
```

---

### **Ensuring a Specific Compose File is Used**
You can specify a different `docker-compose.yml` file:

```yaml
- name: Use a custom compose file
  hosts: all
  tasks:
    - name: Start services using a specific compose file
      community.docker.docker_compose_v2:
        project_src: /opt/docker_app
        files:
          - docker-compose.custom.yml
        state: present
```

🔹 **This ensures `docker-compose.custom.yml` is used instead of `docker-compose.yml`.**

---

### **Restarting and Updating Services**
#### **Restart All Containers**
```yaml
- name: Restart Docker Compose services
  hosts: all
  tasks:
    - name: Restart all services
      community.docker.docker_compose_v2:
        project_src: /opt/docker_app
        state: restarted
```

#### **Pull Latest Images and Restart Services**
```yaml
- name: Pull new images and restart services
  hosts: all
  tasks:
    - name: Pull latest images
      community.docker.docker_compose_v2:
        project_src: /opt/docker_app
        pull: always
        state: present
```

🔹 **`pull: always`** ensures that the latest Docker images are used.

---

### **Stopping and Removing Services**
#### **Stop Services Without Removing Containers**
```yaml
- name: Stop services
  hosts: all
  tasks:
    - name: Stop Docker Compose services
      community.docker.docker_compose_v2:
        project_src: /opt/docker_app
        state: stopped
```

#### **Remove Containers and Volumes**
```yaml
- name: Remove services and volumes
  hosts: all
  tasks:
    - name: Remove services and associated volumes
      community.docker.docker_compose_v2:
        project_src: /opt/docker_app
        state: absent
```

🔹 **`state: absent`** completely removes all containers, networks, and volumes.

---

### **Example: Managing Docker Compose in an Ansible Role**
You can structure Docker Compose management as an **Ansible role**.

#### **Directory Structure for the Role (`docker_compose_role/`)**
```
docker_compose_role/
├── tasks/
│   └── main.yml
├── templates/
│   └── docker-compose.yml.j2
├── vars/
│   └── main.yml
```

#### **Define Variables in `vars/main.yml`**
```yaml
docker_project_src: /opt/docker_app
docker_compose_file: docker-compose.yml
```

#### **Use a Jinja2 Template for `docker-compose.yml.j2`**
```yaml
version: '3.8'
services:
  web:
    image: nginx
    ports:
      - "80:80"
  db:
    image: mariadb
    environment:
      MYSQL_ROOT_PASSWORD: "{{ db_root_password }}"
```

#### **Define Tasks in `tasks/main.yml`**
```yaml
- name: Deploy Docker Compose stack
  template:
    src: docker-compose.yml.j2
    dest: "{{ docker_project_src }}/docker-compose.yml"

- name: Start services
  community.docker.docker_compose_v2:
    project_src: "{{ docker_project_src }}"
    state: present
```

#### **Use the Role in a Playbook**
```yaml
- name: Deploy Docker Compose with Role
  hosts: all
  roles:
    - docker_compose_role
```

---

## **Summary**
- **Start services** → `state: present`
- **Restart services** → `state: restarted`
- **Stop services** → `state: stopped`
- **Remove services** → `state: absent`
- **Pull latest images** → `pull: always`
- **Use a specific Compose file** → `files: ["docker-compose.custom.yml"]`
- **Use roles** → Automate Docker Compose deployments efficiently.

---